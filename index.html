<!DOCTYPE html>
<html>
  <head>
    <title>mp4cut.js -- JS/clientside based clipping of an .mp4 file - rewrites header and only (losslessly) sends desired A/V packets for the desired start/end range</title>
    <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
    <script src="http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/mp4box.all.min.js"></script>
    <script src="http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/downloader.js"></script>
    <!--
    <script src="../mp4box.all.js"></script>
    <script src="../mp4box.js/test/downloader.js"></script>
    -->
  </head>
  <body>
    <h1>mp4cut.js -- JS/clientside based clipping of an .mp4 file - rewrites header and only (losslessly) sends desired A/V packets for the desired start/end range</h1>
    Uses mp4/moov parsing JS from <a href="http://download.tsi.telecom-paristech.fr/gpac/mp4box.js/">mp4box.js</a><br/>
    <b>Uses the Media Source API</b><br/>
    <a href="https://hacks.mozilla.org/2015/07/streaming-media-on-demand-with-media-source-extensions/">https://hacks.mozilla.org/2015/07/streaming-media-on-demand-with-media-source-extensions/</a><br/>
    to inject video to this tag:<br/>
    <video id="vxxx" controls autoplay width="320" height="240"></video><br/>
    <b style="color:red">(media files need to be served using something like <code>ruby -run -e httpd . -p 8000</code> for http RANGE requests, and the server need to support CORS options)</b><br/>

    <hr/>
    <div id="log" style="font-family:monospace; white-space:pre"><b>LOG:</b><br/></div>
<script>
 /*
    # to build your own tailored mp4box.js:
 git clone git@github.com:gpac/mp4box.js.git;
 brew install npm;
 npm install -g grunt-cli;
 cd mp4box.js;
 npm install;
 grunt;
 */

 var FI='http://ia600301.us.archive.org/cors_get.php?path=/27/items/stairs/stairs.mp4';
//FI='stairs.mp4';
 var START=10;
 var END=20;
 var FETCH_ENTIRE_FILE=false;
 var fragment=false;

 var mimeCodec = 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"';

 if (!fragment){
 window.mediaSource = new MediaSource();
 mediaSource.append = function(buffer){ // NOTE: tracey added function
   if (!mediaSource.started){
     mediaSource.started = true;//NOTE: this is *us* extending the object
     var video = document.querySelector('video');
     video.src = URL.createObjectURL(mediaSource);
     mediaSource.addEventListener('sourceopen', function(){
       log('mediaSource sourceopen()');
       mediaSource.sourceBuffer = mediaSource.addSourceBuffer(mimeCodec);//NOTE: this is *us* extending the object   
       mediaSource.sourceBuffer.appendBuffer(buffer);
     });
   }
   else {
     mediaSource.sourceBuffer.appendBuffer(buffer);
   }
 };
 }

 
 //FI='COMW_20130726_023000_The_Daily_Show_With_Jon_Stewart.mp4';
 //START=1207;
 //END=START + 30;

//Log.setLogLevel(Log.debug);
Log.setLogLevel(Log.info);

 var log=function(){
   for (arg in arguments)
     $('#log').append(arguments[arg]+"\n");
   if (typeof(console)=='undefined')
     return;
   console.log(arguments);
 };



 
 
 window.mp4box = new MP4Box();
 mp4box.onMoovStart = function () {
   log("Starting to receive File Information");
 }
 mp4box.onError = function(e) {
   log("error:");
   log(e);
 };
 mp4box.onReady = function(info) {
   log("onReady info:");
   log(info);


   if (fragment){

     mp4box.onSegment = function (id, user, buffer) {
       log("Received segment on track "+id+" for object "+user+" with a length of "+buffer.byteLength);
     }
     
     for (var trak in mp4box.getInfo().tracks){
       mp4box.setSegmentOptions(mp4box.getInfo().tracks[trak].id, "xxxx"/*{sb:mediaSource.sourceBuffer}*/,  {rapAlignment:true});
       log('setseg on trak:'+trak+', id:'+mp4box.getInfo().tracks[trak].id);
     }
     
     /*
     // mp4box.createSingleSampleMoof  ?? xxxx
     mp4box.createFragment('xxx ignored??',
                           1, //track_id
                           3 //sampleNumber
     );
      */

     mp4box.xxxseg = mp4box.initializeSegmentation();
     mp4box.start();

     log('fragmentedTracks:');
     log(mp4box.fragmentedTracks);
     //mediaSource.append(mp4box.writeFile()); //xxxxxxxx
     //mediaSource.append(mp4box.xxxseg[0].buffer); //xxxxxxxx
     //mediaSource.append(mp4box.xxxseg[1].buffer); //xxxxxxxx
     
     log('what the frag?');
     return;
   }
   
   
//log("SEEK ME"); log(mp4box.seek(10, true)); return;//xxxxxxxxxx
//   mediaSource.append(mp4box.writeFile()); return; //xxxxxxxx
     
   
   mp4box.stop();//xxxx no work?
   
   var stts_get_duration = function(stts){
     var duration = 0;
     for(var i=0; i < stts.sample_counts.length; i++)
       duration += stts.sample_counts[i] * stts.sample_deltas[i];
     return duration;
   };

   var trak_time_to_moov_time = function(t, moov_time_scale, trak_time_scale){
     return t * moov_time_scale / trak_time_scale;
   };

   
   window.moov = mp4box.inputIsoFile.moov;
   window.mdat = mp4box.inputIsoFile.mdats[0];
   var moov_time_scale = moov.mvhd.timescale;
   var nearestKeyframe=0;
   var nearestKeyframeTrak=-1;
   var starts=[]; // NOTE: these become starting sample *NUMBER* (not time!) for each track
   var ends=[];   // NOTE: these become ending   sample *NUMBER* (not time!) for each track
   for (var trak in moov.traks){
     log('================== NEW TRAK ===================');
     var trak_time_scale = moov.traks[trak].mdia.mdhd.timescale;
     log('stco (chunk offsets)');
     //log(moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets);
     log('stts (time to sample) (always len 1 for IA vids):');
     log(moov.traks[trak].mdia.minf.stbl.stts);

     var duration = moov.traks[trak].mdia.minf.stbl.stts.sample_deltas[0]; //xxx may need to expand for non-IA (they have just 1)...
     var duration_time = duration / trak_time_scale; //eg: 100/2997


     // find the actually wanted start and end, after initing to max range
     starts[trak] = 0;
     ends[trak] = moov.traks[trak].samples.length-1;
     for (var i=0; i < moov.traks[trak].samples.length; i++){
       var pts = i * duration / trak_time_scale;
       if (pts <= START)
         starts[trak] = i;
       if (pts <= END)
         ends[trak] = i;
       else if (pts > END)
         break;
     }
     


     // now for the video track, adjust ITS start to the nearest keyframe BEFORE OR AT it
     if (moov.traks[trak].mdia.minf.stbl.stss){
       log('moov_time_scale:'+moov_time_scale);
       log('trak_time_scale:'+trak_time_scale);
       log('stss (list of video keyframes)');
       log(moov.traks[trak].mdia.minf.stbl.stss.sample_numbers);
       var sample_numbers=moov.traks[trak].mdia.minf.stbl.stss.sample_numbers;
       for (var i in sample_numbers){
         // pts:  179*100/2997 ==> 5.972639305972639
         var pts=(sample_numbers[i]-1) * duration / trak_time_scale;//xxx check the -1 math, etc.
         if (pts <= START){
           nearestKeyframeTrak = trak;
           nearestKeyframe = sample_numbers[i];
         }
         else{
           break;
         }
           
         log('keyframe #: '+i+', val='+sample_numbers[i]+', pts='+pts);
       }
       log('nearestKeyframe: '    + nearestKeyframe); // xxx this is a sample NUMBER (not time)!
     }
   }//end for (var trak in moov.traks)


   

   if (nearestKeyframeTrak >= 0){
     // means we found the best VIDEO KEYFRAME to sync start to above -- we'll use that!
     log('STARTS: ');log(starts);
     starts[nearestKeyframeTrak] = nearestKeyframe;
   }
   log('STARTS: ');log(starts);
   log('ENDS: '  );log(ends);


   if (0 && "xxx"){
     starts=[272,391];
     ends=[521,749];
     log('STARTS: ');log(starts);
     log('ENDS: '  );log(ends);
   }
   
   


   var moov_duration = 0;
   var end_offset = 0;
   var skip_from_start = Number.MAX_VALUE;
   var mdat_start = mdat.start;//xxxx
   var mdat_size = mdat.size;//xxxx
   for (var trak in moov.traks){
     var start = starts[trak];
     var end   = ends[trak];
     
     var skip = (moov.traks[trak].samples[start].offset -
                 moov.traks[trak].samples[0].offset);
     if (skip < skip_from_start)
       skip_from_start = skip;
     log('CAN SKIP '+skip+' BYTES!');

     if ((end+1) < moov.traks[trak].samples.length){
       var end_pos = moov.traks[trak].samples[end].offset;
        if(end_pos > end_offset)
          end_offset = end_pos;
        log("New endpos=" + end_pos);
        log("Trak can skip "+(mdat_start + mdat_size - end_offset)+" bytes at end");
     }
     
     // adust STTS
     if (moov.traks[trak].mdia.minf.stbl.stts){
       var samples = moov.traks[trak].samples;
       var entries = 0;
       var s = start;
       var sample_counts=[];
       var sample_deltas=[];
       while (s != end){
         var sample_count=1;
         //log(s+' -v- '+end);
         var sample_duration = samples[s+1].dts - samples[s].dts;
         while ((++s) < end){
           //log(s+' -v- '+end);
           if ((samples[s+1].dts - samples[s].dts) != sample_duration){
             alert('xxx');
             break;
           }
           ++sample_count;
         }

         sample_counts[entries] = sample_count;
         sample_deltas[entries] = sample_duration;
         entries++;
       }
       moov.traks[trak].mdia.minf.stbl.stts.sample_counts = sample_counts;
       moov.traks[trak].mdia.minf.stbl.stts.sample_deltas = sample_deltas;
     }

     // adjust CTTS
     if (moov.traks[trak].mdia.minf.stbl.ctts) alert("need to update CTTS!");

     // adjust STSC (chunkmap) and STCO (chunk offsets)
     if (moov.traks[trak].mdia.minf.stbl.stsc){
       var stsc = moov.traks[trak].mdia.minf.stbl.stsc;
       
       // find the chunk that has the desired start sample in it
       var chunk_start=0;
       if (!stsc.first_chunk.length  &&
           !stsc.samples_per_chunk.length  &&
           !stsc.sample_description_index.length){
         // eg: MP4Box -dash 10000 -rap -frag-rap c.mp4
       }
       else{
         // eg: normal IA video
         for (var nChunks=stsc.samples_per_chunk.length/*xxx verify!*/;   chunk_start < nChunks; chunk_start++){
           if (stsc.first_chunk[nChunks] + stsc.samples_per_chunk[nChunks] > start)
             break; // found the right chunk!
         }
         if (stsc.first_chunk.length!=1  ||  stsc.first_chunk[0]!=1  ||
             stsc.samples_per_chunk.length!=1  ||  stsc.samples_per_chunk[0]!=1  ||
             stsc.sample_description_index.length!=1  ||  stsc.sample_description_index[0]!=1){
           alert('cant be this lazy tracey STSC needs work xxx!');
         }
       }
       var chunk_end=moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets.length;//xxx (see above alert!)
       var entries=0;
       for (var i=chunk_start; i < chunk_end; i++){
         moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets[entries] =
         moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets[i]; // xxx need to subtract amount of header we will shrink down by  *PLUS*  the first byte jump distance between orig vs ne A/V packets...
         entries++;
       }
       moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets = moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets.slice(0,entries);//xxx slice efficient enough?!
     }
     

     // adjust STSS (sync samples)
     if (moov.traks[trak].mdia.minf.stbl.stss){
       var stss = moov.traks[trak].mdia.minf.stbl.stss;
       var i=0;
       var entries=0;
       for (; i < stss.sample_numbers.length; i++){
         var sync_sample = stss.sample_numbers[i];
         if (sync_sample >= end + 1)
           break;
         moov.traks[trak].mdia.minf.stbl.stss.sample_numbers[entries++] =
           sync_sample - start;
       }
       moov.traks[trak].mdia.minf.stbl.stss.sample_numbers = moov.traks[trak].mdia.minf.stbl.stss.sample_numbers.slice(0,entries);//xxx slice efficient enough?!
     }


     // adjust STSZ (sample sizes)
     if (moov.traks[trak].mdia.minf.stbl.stsz){
       var stsz = moov.traks[trak].mdia.minf.stbl.stsz;
       if (stsz.sample_sizes.length){
         var entries=0;
         for (var i=start; i < end; i++)
           moov.traks[trak].mdia.minf.stbl.stsz.sample_sizes[entries++] = stsz.sample_sizes[i];
         moov.traks[trak].mdia.minf.stbl.stsz.sample_sizes = moov.traks[trak].mdia.minf.stbl.stsz.sample_sizes.slice(0,entries);//xxx slice efficient enough?!
       }
     }     


     // fixup trak (duration)
     var trak_duration = stts_get_duration(moov.traks[trak].mdia.minf.stbl.stts);
     var trak_time_scale =  moov.traks[trak].mdia.mdhd.timescale;
     {
       var duration = trak_time_to_moov_time(trak_duration, moov_time_scale, trak_time_scale);
       moov.traks[trak].mdia.mdhd.duration = trak_duration;
       moov.traks[trak].tkhd.duration = duration;
       log('trak: new duration: ' + duration);
       
       if (duration > moov_duration)
         moov_duration = duration;
     }
   }//end for (var trak in moov.traks)


   moov.mvhd.duration = moov_duration;
   log("moov: new_duration="+(moov_duration / moov_time_scale)+" seconds");

   // subtract bytes we skip at the front of the mdat atom
   var offset = 0 - skip_from_start;
   log("shifting offsets by " + offset);   
   
   log("moov: writing header");

   // compute moov header size
   var tmpxxx = mp4box.writeFile();
   var moov_size = tmpxxx.byteLength;
   log("moov size: "+moov_size);
   delete tmpxxx;
   
   // add new moov size
   offset += moov_size;
   log("shifting offsets by " + offset);
   
   // moov_shift_offsets_inplace(moov, offset);
   for (var trak in moov.traks){
     for (var i=0; i < moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets.length; i++)
       moov.traks[trak].mdia.minf.stbl.stco.chunk_offsets[i] += offset;
   }//end for (var trak in moov.traks)
   
   
   //create_traffic_shaping(moov, ... //xxx ??!
   


 };//end mp4box.onReady..


 
 


 var downloader = new Downloader();
 downloader.setInterval(100);
 downloader.setChunkSize(2000000);
 downloader.setUrl(FI);
 downloader.start();

 downloader.setCallback(
   function (response, end, error) { 
     log('DL callback()');
     log('end: '+end);
     var nextStart = 0;
     if (response){
       nextStart = mp4box.appendBuffer(response);
       //mediaSource.append(response);
     }
     
     if (end){
       mp4box.flush();
//mediaSource.append(mp4box.writeFile()); //xxxxxxxx
     }
     else {
       if (!FETCH_ENTIRE_FILE  &&  mp4box.readySent)
         downloader.stop();
       else
         downloader.setChunkStart(nextStart);
     }     
     if (error)
       reset();
   }
 );



</script>
</body>
</html>
